-- COMPLETE VOTING ROUTE IMPLEMENTATION
-- This file contains the complete voting system that should be restored once voting tables are created
-- File: src/app/api/voting/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { getSql } from '@/lib/database';

// Type-safe database result wrapper
// eslint-disable-next-line @typescript-eslint/no-explicit-any
type DatabaseResult = Record<string, any>[];

type VotingPhase = 'waiting' | 'pitching' | 'voting' | 'break' | 'completed';

interface TeamVoteCount {
  upvotes: number;
  downvotes: number;
  totalScore: number;
}

interface TeamRecord {
  id: string;
  name: string;
  team_id: string;
  team_name: string;
  has_presented: boolean;
  presentation_order: number;
  downvotes_used: number;
  is_currently_presenting: boolean;
  members_completed?: number;
  team_total_score?: number;
}

interface VotingSessionRecord {
  id: string;
  round_id: string;
  current_presenting_team: string;
  phase: VotingPhase;
  phase_start_time: string;
  phase_end_time: string;
  pitch_duration: number;
  voting_duration: number;
  total_time_limit: number;
  voting_enabled: boolean;
  is_active: boolean;
  created_at: string;
}

interface VotingTeamStatus {
  teamId: string;
  teamName: string;
  hasPresented: boolean;
  presentationOrder: number;
  votesReceived: TeamVoteCount;
  downvotesUsed: number;
  isCurrentlyPresenting: boolean;
  canVote: boolean;
}

interface VotingSession {
  id: string;
  round_id: string;
  current_presenting_team: string;
  phase: VotingPhase;
  phase_start_time: Date;
  phase_end_time: Date;
  pitch_duration: number;
  voting_duration: number;
  teams: VotingTeamStatus[];
  created_at: Date;
}

const voteSchema = z.object({
  fromTeamId: z.string(),
  toTeamId: z.string(),
  voteType: z.enum(['upvote', 'downvote'])
});

const phaseControlSchema = z.object({
  action: z.enum(['start_pitch', 'start_voting', 'next_team', 'end_session']),
  teamId: z.string().optional()
});

// Get or create voting session
async function getVotingSession(): Promise<VotingSession | null> {
  try {
    const sql = getSql();
    
    // Get active voting session
    const sessionResult = await sql`
      SELECT * FROM voting_sessions
      WHERE is_active = true
      ORDER BY created_at DESC
      LIMIT 1
    ` as DatabaseResult;

    if (sessionResult.length === 0) {
      return null;
    }

    const session = sessionResult[0] as VotingSessionRecord;

    // Get teams for this session
    const teamsResult = await sql`
      SELECT 
        t.id as team_id,
        t.team_name,
        t.presentation_order,
        COALESCE(vt.has_presented, false) as has_presented,
        COALESCE(vt.downvotes_used, 0) as downvotes_used,
        CASE WHEN vs.current_presenting_team = t.id THEN true ELSE false END as is_currently_presenting
      FROM teams t
      LEFT JOIN voting_teams vt ON t.id = vt.team_id AND vt.session_id = ${session.id}
      JOIN voting_sessions vs ON vs.id = ${session.id}
      WHERE t.status = 'active'
      ORDER BY t.presentation_order ASC
    ` as TeamRecord[];

    // Calculate vote counts for each team
    const teams = await Promise.all(
      teamsResult.map(async (team) => {
        const voteStats = await sql`
          SELECT 
            COUNT(CASE WHEN vote_type = 'upvote' THEN 1 END) as upvotes,
            COUNT(CASE WHEN vote_type = 'downvote' THEN 1 END) as downvotes,
            SUM(points) as total_score
          FROM team_votes
          WHERE to_team_id = ${team.team_id} AND session_id = ${session.id}
        ` as DatabaseResult;

        const stats = (voteStats[0] || { upvotes: 0, downvotes: 0, total_score: 0 }) as {
          upvotes: number;
          downvotes: number;
          total_score: number;
        };

        return {
          teamId: team.team_id,
          teamName: team.team_name,
          hasPresented: team.has_presented,
          presentationOrder: team.presentation_order,
          votesReceived: {
            upvotes: Number(stats.upvotes) || 0,
            downvotes: Number(stats.downvotes) || 0,
            totalScore: Number(stats.total_score) || 0
          },
          downvotesUsed: Number(team.downvotes_used) || 0,
          isCurrentlyPresenting: team.is_currently_presenting,
          canVote: !team.is_currently_presenting
        };
      })
    );

    return {
      id: (session as VotingSessionRecord).id,
      round_id: (session as VotingSessionRecord).round_id,
      current_presenting_team: (session as VotingSessionRecord).current_presenting_team || '',
      phase: (session as VotingSessionRecord).phase as VotingPhase,
      phase_start_time: new Date((session as VotingSessionRecord).phase_start_time),
      phase_end_time: new Date((session as VotingSessionRecord).phase_end_time),
      pitch_duration: (session as VotingSessionRecord).pitch_duration,
      voting_duration: (session as VotingSessionRecord).voting_duration,
      teams,
      created_at: new Date((session as VotingSessionRecord).created_at)
    };

  } catch (error) {
    console.error('Error getting voting session:', error);
    return null;
  }
}

// Create new voting session
async function createVotingSession(): Promise<VotingSession | null> {
  try {
    const sql = getSql();
    
    // Deactivate any existing sessions
    await sql`UPDATE voting_sessions SET is_active = false WHERE is_active = true`;

    // Create new session
    const sessionResult = await sql`
      INSERT INTO voting_sessions (
        round_id, phase, phase_start_time, phase_end_time, 
        pitch_duration, voting_duration, is_active
      )
        VALUES ('round2', 'waiting', ${new Date()}, ${new Date()}, 90, 30, true)
        RETURNING *
      ` as DatabaseResult;

    const session = sessionResult[0] as { id: string };

    // Initialize voting teams
    const teams = await sql`SELECT id, team_name FROM teams WHERE status = 'active' ORDER BY id` as DatabaseResult;
    
    for (let i = 0; i < teams.length; i++) {
      await sql`
        INSERT INTO voting_teams (session_id, team_id, presentation_order)
        VALUES (${session.id}, ${(teams[i] as { id: string }).id}, ${i + 1})
      `;
      
      // Update team presentation order
      await sql`
        UPDATE teams SET presentation_order = ${i + 1} WHERE id = ${(teams[i] as { id: string }).id}
      `;
    }

    return await getVotingSession();
  } catch (error) {
    console.error('Error creating voting session:', error);
    return null;
  }
}

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const action = searchParams.get('action');

    let votingSession = await getVotingSession();

    // Create session if none exists
    if (!votingSession) {
      votingSession = await createVotingSession();
      if (!votingSession) {
        return NextResponse.json(
          { success: false, error: 'Failed to create voting session' },
          { status: 500 }
        );
      }
    }

    if (action === 'status') {
      // Calculate time remaining in current phase
      const now = new Date();
      const timeRemaining = Math.max(0, Math.floor((votingSession.phase_end_time.getTime() - now.getTime()) / 1000));

      return NextResponse.json({
        success: true,
        session: {
          ...votingSession,
          timeRemaining,
          constraints: {
            maxDownvotes: 3,
            pitchDuration: 90,
            votingDuration: 30,
            canVoteForSelf: false
          }
        }
      });
    }

    if (action === 'results') {
      // Return final voting results
      const results = votingSession.teams
        .map(team => ({
          teamId: team.teamId,
          teamName: team.teamName,
          votingScore: team.votesReceived.totalScore,
          upvotes: team.votesReceived.upvotes,
          downvotes: team.votesReceived.downvotes,
          hasPresented: team.hasPresented
        }))
        .sort((a, b) => b.votingScore - a.votingScore)
        .map((team, index) => ({ ...team, rank: index + 1 }));

      return NextResponse.json({
        success: true,
        results,
        session: votingSession
      });
    }

    return NextResponse.json({
      success: true,
      session: votingSession
    });

  } catch (error) {
    console.error('Error in GET voting:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to fetch voting data' },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const sql = getSql();
    const body = await request.json();
    const { searchParams } = new URL(request.url);
    const action = searchParams.get('action');

    const votingSession = await getVotingSession();
    if (!votingSession) {
      return NextResponse.json(
        { success: false, error: 'No active voting session' },
        { status: 404 }
      );
    }

    if (action === 'vote') {
      const { fromTeamId, toTeamId, voteType } = voteSchema.parse(body);

      // Validate voting constraints
      if (votingSession.phase !== 'voting') {
        return NextResponse.json(
          { success: false, error: 'Voting is not currently active' },
          { status: 400 }
        );
      }

      if (fromTeamId === toTeamId) {
        return NextResponse.json(
          { success: false, error: 'Cannot vote for your own team' },
          { status: 400 }
        );
      }

      const votingTeam = votingSession.teams.find(t => t.teamId === fromTeamId);
      const receivingTeam = votingSession.teams.find(t => t.teamId === toTeamId);

      if (!votingTeam || !receivingTeam) {
        return NextResponse.json(
          { success: false, error: 'Team not found' },
          { status: 404 }
        );
      }

      if (!votingTeam.canVote) {
        return NextResponse.json(
          { success: false, error: 'Team cannot vote at this time' },
          { status: 400 }
        );
      }

      // Check downvote limit
      if (voteType === 'downvote' && votingTeam.downvotesUsed >= 3) {
        return NextResponse.json(
          { success: false, error: 'Maximum downvotes (3) already used. You must upvote.' },
          { status: 400 }
        );
      }

      // Check if team already voted for this team in this session
      const existingVote = await sql`
        SELECT id FROM team_votes
        WHERE from_team_id = ${fromTeamId} AND to_team_id = ${toTeamId} AND session_id = ${votingSession.id}
      ` as DatabaseResult;

      if (existingVote.length > 0) {
        return NextResponse.json(
          { success: false, error: 'Already voted for this team' },
          { status: 400 }
        );
      }

      // Record the vote
      try {
        // Insert vote record
        const voteResult = await sql`
          INSERT INTO team_votes (
            from_team_id, to_team_id, vote_type, points, session_id
          )
          VALUES (${fromTeamId}, ${toTeamId}, ${voteType}, ${voteType === 'upvote' ? 1 : -1}, ${votingSession.id})
          RETURNING *
        ` as DatabaseResult;

        // Update downvote count if downvote
        if (voteType === 'downvote') {
          await sql`
            UPDATE voting_teams
            SET downvotes_used = downvotes_used + 1
            WHERE team_id = ${fromTeamId} AND session_id = ${votingSession.id}
          `;
        }

        // Update team voting score
        await sql`
          UPDATE teams
          SET voting_score = COALESCE(voting_score, 0) + ${voteType === 'upvote' ? 1 : -1},
              total_score = COALESCE(total_score, 0) + ${voteType === 'upvote' ? 1 : -1},
              last_activity = NOW(),
              updated_at = NOW()
          WHERE id = ${toTeamId}
        `;

        // Get updated session data
        const updatedSession = await getVotingSession();

        return NextResponse.json({
          success: true,
          vote: voteResult[0],
          session: updatedSession,
          message: `${voteType} recorded successfully`
        });
      } catch (voteError) {
        console.error('Error recording vote:', voteError);
        return NextResponse.json(
          { error: 'Failed to record vote' },
          { status: 500 }
        );
      }
    }

    if (action === 'control') {
      // Admin controls for managing phases
      const { action: controlAction, teamId } = phaseControlSchema.parse(body);
      const now = new Date();

      try {
        switch (controlAction) {
          case 'start_pitch':
            if (!teamId) {
              throw new Error('Team ID required for starting pitch');
            }

            // Update session to pitching phase
            await sql`
              UPDATE voting_sessions
              SET current_presenting_team = ${teamId},
                  phase = 'pitching',
                  phase_start_time = ${now},
                  phase_end_time = ${new Date(now.getTime() + 90000)}
              WHERE id = ${votingSession.id}
            `;

            break;

          case 'start_voting':
            if (votingSession.phase !== 'pitching') {
              throw new Error('Must be in pitching phase to start voting');
            }

            await sql`
              UPDATE voting_sessions
              SET phase = 'voting',
                  phase_start_time = ${now},
                  phase_end_time = ${new Date(now.getTime() + 30000)}
              WHERE id = ${votingSession.id}
            `;

            break;

          case 'next_team':
            // Mark current team as presented
            if (votingSession.current_presenting_team) {
              await sql`
                UPDATE voting_teams
                SET has_presented = true
                WHERE team_id = ${votingSession.current_presenting_team} AND session_id = ${votingSession.id}
              `;
            }

            await sql`
              UPDATE voting_sessions
              SET phase = 'break',
                  current_presenting_team = NULL
              WHERE id = ${votingSession.id}
            `;

            break;

          case 'end_session':
            await sql`
              UPDATE voting_sessions
              SET phase = 'completed',
                  current_presenting_team = NULL,
                  is_active = false
              WHERE id = ${votingSession.id}
            `;

            break;
        }

        // Get updated session
        const updatedSession = await getVotingSession();

        return NextResponse.json({
          success: true,
          session: updatedSession,
          message: `${controlAction} executed successfully`
        });
      } catch (controlError) {
        console.error('Error executing control action:', controlError);
        return NextResponse.json(
          { error: 'Failed to execute control action' },
          { status: 500 }
        );
      }
    }

    return NextResponse.json(
      { success: false, error: 'Invalid action' },
      { status: 400 }
    );

  } catch (error) {
    console.error('Voting error:', error);

    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { success: false, error: 'Invalid request data' },
        { status: 400 }
      );
    }

    return NextResponse.json(
      { success: false, error: 'Failed to process voting request' },
      { status: 500 }
    );
  }
}
